**1) Решение:** 
Сигнал y1[n] будет проще и быстрее реализовать, потому что вычисление y1[n] зависит только от входного сигнала x[n] и его соседних значений. Значит, каждый элемент y1[n] мы можем вычислить независимо.

**2) Решение:**
Код дивергенции не произойдет.
Обьяснение:
1) Внутри каждого warp, ```get_local_id(0)``` меняется от 0 до 31, а ```get_local_id(1)``` остается постоянным
2) Вычисляем idx для каждого потока в warp: idx = get_local_id(1) + 32 * get_local_id(0)
3) Так как ```get_local_id(1)``` константа внутри warp, то idx % 32 = (get_local_id(1) + 32 * get_local_id(0)) % 32 = get_local_id(1)
4) Значит, внутри warp значение idx % 32 одинаково для всех потоков и равно get_local_id(1)
5) Условие ```idx % 32 < 16``` либо истинно для всех потоков warp, либо ложно, в зависимости от значения ```get_local_id(1)```
6) Поэтому все потоки внутри warp выполняют либо функцию ```foo()```, либо ```bar()```, без разеделения пути исполнения.

**3) Решение:**
a:
Обращение к памяти будет coalesced.
Количество кеш-линий записей в одной рабочей группе: 32.
Обьяснение:
0) Размер float: 4 байта (следовательно в одно кеш-линии 32 float)
1) Индекс доступа: ```index = get_local_id(0) + 32 * get_local_id(1)```
2) Внутри warp, get_local_id(1) постоянен, get_local_id(0) меняется от 0 до 31.
3) Индексы доступа будут последовательными: ```index = base + get_local_id(0)```
4) Все 32 потока в warp обращаются к последовательным адресам, которые укладываются в одну кеш-линию.
5) Так как есть 32 warp в рабочей группе, общее количество кеш-линий: 32.

b:
Ответ:
Обращение к памяти не будет calesced.
Количество кеш-линий записей в одной рабочей группе: 1024.
Обьяснение:
1) Индекс доступа: ```index = get_local_id(1) + 32 * get_local_id(0)```
2) Внутри warp, get_local_id(1) постоянен, но доступы распределены с шагом: ```index = y + 32 * get_local_id(0)```
3) Каждый поток обращается к адресу, отстоящему на 128 байт от предыдущего
4) Каждый поток в warp обращается к отдельной кеш-линии.
5) В результате, каждый warp записывает в 32 разные кеш-линии.
6) Общее количество кеш-линий: 32 * 32 = 1024.

c:
Ответ:
Обращение к памяти будет частично calesced.
Количество кеш-линий записей в одной рабочей группе: 64.
Обьяснение:
1) Индекс доступа: ```index = 1 + get_local_id(0) + 32 * get_local_id(1)```
2) Внутри warp, индексы смещены на 1: ```index = base + 1 + get_local_id(0)```
3) Первые 31 потока обращаются к одному кеш-линии, последний поток (get_local_id(0) = 31) обращается к следующей кеш-линии.
4) Значит, каждый warp записывает в 2 кеш-линии.
5) Общее количество кеш-линий: 32 * 2 = 64.